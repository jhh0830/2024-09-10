<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area {
            width: 300px;
            border:  1px solid red;
        }

        .small {
            height: 150px;
        }
        .big{
            height: 250px;
        }
    </style>
</head>
<body>

    <h1>배열</h1>
    <!--
        * 자바 시간에 배웠던 배열 개념
        "같은" 자료형의 값 "여러개"를 묶어서 보관할 수 있는 개념
        배열의 사이즈를 할당하면 사이즈 변경 불가!!
    -->
   <p>
        자바스크립트 에서는 변수 선언 시 별도의 자료형 지정이 없었기 때문에
        마찬가지로 배열 공간에도 어떤 자료형의 값들이던 간에
        다 차곡차곡 담아낼 수 있음!!   (자바의 컬렉션과 유사)    
    </p>

    <button onclick="arrayTest1();">
        확인하기
    </button>

    <div id="area1" class="area small"></div>

    <script>
        function arrayTest1(){

            var arr = ["홍길동","서울", 20, true,[1,2,3]];


            console.log(arr);
            console.log(arr[2]); // 20
            console.log(arr[4]); // [1,2,3]
            console.log(arr[4],[1]) // 2


            let area1 = document.getElementById("area1");

            // 반복문을 활용해서 div 에 출력
            // 배열의 크기 : 배열명.length
            /*
            for(let i = 0; i < arr.length; i++){
                area1.innerHTML = arr[i] + "<br>";
            }
            */

            // 배열의 0번 인덱스에서부터 마지막 인덱스가지
            // 순차적으로 모두 접근할 목적이라면 (반복을 돌릴 목적이라면)
            // 일반 for 문 뿐만 아니라 for in 문 활용 가능!!
            // > 향상된 for 문 (foreach 문) 은 없지만 for in 문은 있음!!
            
            // [ 표현법 ]
            // for(변수선언문 in 배열명)
            for(let i in arr) {
                //  i = 0, 1, 2, 3, 4
                // i 에는 각 인덱스 추가 순차적으로 담겨옴


                area1.innerHTML += arr[i] + "<br>";
            }


        }
    </script>


    <br>
    <hr>

    <h3>* 배열의 선언</h3>

    <!-- 
        * 자바 시간에 배웠던 배열 선언 방식

        자료형[] 배열명; //선언
        배열명 = new 자료형[사이즈]; // 할당
        // > 여기까지 해줘야 배열 사용 가능!!

        자료형[] 배열명 = new 자료형[사이즈]; // 선언 및 할당
        // > 반드시 할당을 통해 내가 사용할 배열이
        //   몇칸짜리 배열인지 알려줘야함!!
        // > 한번 할당된 사이즈는 변경 불가!!

    -->

    <p>
        배열 선언 시 배열의 크기를 지정한 채로 선언하거나,
        크기를 지정하지 않아도 됨 <br>
        즉, 배열 크기의 제약이 없다. (자바의 컬렉션)과 유사

    </p>

    <button onclick="arrayTest2();">확인하기</button>

    <script>
        function arrayTest2(){

            // 배열 선언 표현법
            // 1. Array 라는 생성자함수를 호출하는 방법
            // 2. [] 로 명시적으로 장석하는 방법

            var arr1 = new Array(); // 배열의 크기가 0인 빈 배열
            let arr2 = new Array(3); // 배열의 크기가 3인 빈 배열
            const arr3 = []; // 배열의 크기가 0인 빈 배열

            console.log(arr1);
            console.log(arr2);
            console.log(arr3);

            // 배열에 값 추가
            arr[0]= "바나나";
            arr[1]= "사과";
            arr[2]= "키위";

            console.log(arr1);
            // > 배열에 크기가 3으로 늘어나있다.

            arr2[0] = "자동차";
            arr2[1] = "기차";
            arr2[2] = "도보";
            arr2[10] = "비행기";

            console.log(arr2);
            //  > 배열의 크기가 11로 늘어나있다.
            // [3] ~ [9] 까지는 비어있음!!

            /*
            arr3[0] = 1;
            arr3[1] = 2;
            arr3[2] = 3;
            arr3[3] = 4;
            */

            for(let i = 0; i < 4; i++){

                arr3[i] = i + 1;

            }

            console.log(arr3);
            // > 배열은 const 로 선언하더라도
            //   값을 변경할 수 있다.
            //   사이즈 또한 계속 늘어남!!


            // 왜?
            // 자바스크립트 또한 코드 실행 중 메모리의 stack, heap 영역을 사용
            // 배열의 주소값은 stack 영역에, 배열에 실제 데이터는 heap 영역에 들어있음
            // > stack 영역의 주소값은 계속 고정이기 때문에
            //   const 로 배열을 선언하더라도 값 변경이 가능해짐!!

            // 배열 선언과 동시에 초기화
            var arr4 = new Array("홍길동" , "임꺽정");

            let arr5 = ["java", "oracle", "front-end"];

            console.log(arr4);
            console.log(arr5);



        }
        
    </script>

    <br>
    <hr>
    <h3>* Array 객체의 메소드</h3>
    <h4>
        1) indexOf(찾고자하는요소)
        : 배열에서 해당 요소가 위치해있는 인덱스를 반환

    </h4>

    <div id="area2" class="area small"></div>

    <button onclick="indexOfTest();">확인하기</button>

    <script>
        function indexOfTest(){

            const area2 = document.getElementById("area2");

            // 테스트할 배열 셋팅
            var arr = ["사과","딸기","바나나","복숭아","파인애플"];

            // 사용자로부터 과일명 입력받기

            let fruit= prompt("찾을 과일명을 입력하세요.");

            let index = arr.indexOf(fruit);

            console.log(index);
            // > 배열에 존재하지 않는 요소를 제시했을 경우
            //   -1 이 리턴됨!!

            // 있을 경우 : 당신이 찾는 과일 xxx는  x번째 인덱스에 있습니다
            // 없을 경우 : 당신이 찾는 과일 xxx는 판매하지 않습니다.

            area2.innerHTML = "당신이 찾는 과일 " + fruit + "은(는) ";
            
            if(index == -1){ // 없을 경우

                area2.innerHTML += "판매하지 않습니다.";

            }else { // 있을 경우
                
                area2.innerHTML += index + "번째 인덱스에 있습니다."

            }

            // 참고) 
            // 동등비교 시 == 또는 === 사용 가능
            console.log(1 == 1); //true
            console.log(1 == "1"); // true
            // > == : 동등연산자 (자료형과 무관하게 실제 값만 일치하면 true)
            console.log(1 === "1"); // false
            // > === : 일치연산자 (자료형, 실제 값 둘다 일치해야만 true)

            
            

        }
    </script>

    <br>

    <hr>

    <h4>
        2) concat(배열명, 배열명, ....)
        : 여러개의 배열을 결합하고자 할 때 사용

    </h4>

    <div id="area3" class="area big"></div>

    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest(){

            var area3 = document.getElementById("area3");

            // 테스트용 배열 셋팅
            let arr1 = ["사과","딸기"];
            let arr2 = ["자동차","오토바이","비행기"];


            area3.innerHTML = "arr1 : " + arr1 + "<br>";
            area3.innerHTML += "arr2 : " + arr2 + "<br>";

            area3.innerHTML += "arr1 기준으로 배열 합침 : " + arr1.concat(arr2) + "<br>";

            area3.innerHTML += "다시 arr1 : " + arr1 + "<br>";
            // > 원본 배열에 영향을 미치지 않는 메소드
            //   즉, 두개의 배열을 합쳐서 새로운 배열로 반환

            area3.innerHTML += "arr2 기준으로 배열 합침 : " + arr2.concat(arr1) + "<br>";

            area3.innerHTML += "여러개의 배열 합침 : " + arr1.concat(arr2, [1,2,3], [true, "hi"]);

            // > 내가 원하는 만큼 배열 제시 후 합칠 수 있다.



        }
    </script>

    <br>
    <hr>

    <h4>
        3) reverse()
        : 배열에 담긴 값들ㅇ르 역순으로 바꿔주는 메소드
    </h4>

    <div id="area4" class="area small"></div>

    <button onclick="reverseTest();">확인하기</button>

    <script>
        function reverseTest(){

            let area4 = document.getElementById("area4");

            // 테스트용 배열 셋팅
            var arr = [1,2,3,4,5];

            area4.innerHTML = "arr : " + arr + "<br>";
            area4.innerHTML += "reverse 결과 : " + arr.reverse() + "<br>";
            area4.innerHTML += " 다시 arr  : " + arr + "<br>";
            /*
                arr : 1,2,3,4,5
                reverse 결과 : 5,4,3,2,1
                다시 arr : 5,4,3,2,1
            */
            // xx.reverse  >> 원본 배열에 영향을 미치는 메소드


        }
    </script>

    <br>

    <hr>

    <h4>
        4) sort()
        : 배열 안에 담긴 값들을 오름차순으로 정렬시켜주는 메소드 
    </h4>

    <div id="area5" class="area small"></div>

    <button onclick="sortTest();">확인하기</button>

    <script>
        function sortTest(){

            const area5 = document.getElementById("area5");

            // 테스트할 배열 셋팅

            var arr = ["김가현", "김마현", "김나현", "김라현" , "김다현"];

            area5.innerHTML = "arr : " + arr + "<br>";

            area5.innerHTML += "sort 결과 : " + arr.sort() + "<br>";
            area5.innerHTML += "다시 arr : " + arr + "<br>";
            // xx.sort > 원본 배열에 영향을 미치는 메소드 

            // 내림차순 정렬을 하고 싶다면?
            // > 일단 sort 로 오름차순 정렬 후 reverse 로 역순으로 뒤집어준다.

            area5.innerHTML += "내림차순 정렬 : " + arr.sort().reverse() + "<br>";
            // > 메소드 체이닝 이용!!

            // * 주의사항
            // sort() 는 기본적으로 "문자열" 기준으로만 정렬됨!!
            // 즉, 유니코드 값에 의한 정렬

          let arr2 = [3,6,8,1,11];
          console.log(arr2);

          arr2.sort();

          console.log(arr2); // [1, 11, 3, 6, 8]
          // 정렬 시 "1", "11", "3" ,"6" ,"8"
          // 내부적으로 위와 깉이 문자열로 취급하여 정렬함!!

          // 숫자값으로 정렬을 하고싶다면?
          // 해결방법 : sort 함수 호출 시 인자값으로 
          //            callback  function 를 넘겨준다.

            arr2.sort(function(a, b) {return a - b;});
            // > a, b 를 매개변수로 받아서 a - b 의 결과를 반환
            //   a - b 의 값이 양수인 경우 (즉, a 가 더 큰 경우)
            //   a 와 b 의 순서를 바꿔줌

            console.log(arr2);

            // 내림차순 시?
            arr2.sort(function(a, b){return b - a; });
            
            console.log(arr2);

            

        }
    </script>

    <br>
    <hr>

    <h4>
        5_1) push()
        : 배열의 맨 뒤에 요소를 추가하고 배열의 크기를 반환 <br>
        5_2) pop()
        : 배열의 맨 뒤 요소를 제거하고 제거된 요소를 반환
    </h4>

    <div id="area6" class="area big"></div>

    <button onclick="pushPopTest();">확인하기</button>

    <script>
        function pushPopTest(){

            var area6 = document.getElementById("area6");

            //테스트용 배열 셋팅
            let arr = ["서초동", "방배동", "역삼동", "삼성동", "대치동"];

            area6.innerHTML = "arr : " +arr + "<br>";

            arr.push("신사동");

            area6.innerHTML += "arr 에 push 후 : " + arr + "<br>"; 
            area6.innerHTML += "arr 에 phsh 후 배열의 크기 " + arr.push("논현동") + "<br>";

            area6.innerHTML += "다시 arr : " + arr + "<br>"; 
            // .push >> 원본배열에 영향을 미치는 메소드

            area6.innerHTML += "arr 에 pop 후 : " + arr.pop() + "<br>";
            area6.innerHTML += " 다시 arr : " + arr + "<br>";
            // .pop >> 원본배열에 미치는 메소드

            arr.pop();
            arr.pop();
            arr.pop();

            area6.innerHTML += "최종 arr : " + arr + "<br>"; 
        }
    </script>

    <br>

    <hr>

    <h4>
        6_1) unshift(추가할요소)
        : 배열의 맨 앞에 요소 추가 후 배열의 크기를 반환 <br>
        6_2) shift()
        : 배열의 맨 앞 요소를 제거 후 제거된 요소를 반환 <br>
    </h4>

    <div id="area7" class="area big"></div>

    <button onclick="shiftUnshiftTest();">확인하기</button>

    <script>
        function shiftUnshiftTest(){

            let area7 = document.getElementById("area7");

            var arr = ["야구", "볼링" , "테이스", "탁구"];

            area7.innerHTML = "arr : " + arr +"<br>";

            arr.unshift("농구");

            area7.innerHTML += "arr 에 unshift 후 : " + arr + "<br>";
            area7.innerHTML += " arr 에 unshift 후 배열의 크기 : "+ arr.unshift("당구")+ "<br>";
            area7.innerHTML += "다시 arr : " + arr + "<br>";
            // > 원본배열에 영향을 미치는 메소드

            area7.innerHTML += "arr 에 shift  : " + arr.shift() + "<br>";
            area7.innerHTML += "최종 arr : " + arr + "<br>";
            // > 원본배열에 영향을 미치는 메소드
            
            // * push, pop 과 같이 unshift, shift 또한 선입후출 구조!!
            // > 그럼 선입선출구조를 나타내고싶다면?
            //   unshift 로 데이터 추가, pop 으로 데이터 제거
            //   
        }
    </script>

    <br>
    <hr>

    <h4>
        7_1) slice(시작, 끝)
        : 배열 안의 요소들을 단지 추출해주는 메소드<br>
        7_2) splice(시작, 제거수, 추가값) 
        : 배열을 요소들을 추출해서 제거 및 추가, 추가값 생략 가능<br> 

    </h4>

    <div id="area8" class="area small"></div>

    <button onclick="sliceSpliceTest();">확인하기</button>

    <script>
        function sliceSpliceTest(){

            const area8 = document.getElementById("area8");
            // 테스트할 배열 셋팅
            var arr = ["자바", "오라클", "html", "css", "javascript"];

            area8.innerHTML = "arr : " + arr + "<br>";

            // slice(시작인덱스, 끝인덱스)

            area8.innerHTML += "slice 결과 : " + arr.slice(2,4) + "<br>";
            // > 시작인덱스 ~ 끝인덱스 - 1 까지 추출

            area8.innerHTML += "다시 arr : " + arr + "<br>";
            // > 원본 배열에 영향을 미치는 메소드가 아님

            // splice(시작인덱스, 제거수, 추가할요소)
            area8.innerHTML += "splice 결과 : " + arr.splice(2,2, "spring") + "<br>";
            // > 추가할요소를 생략할 시 slice 와 같은 역할

            area8.innerHTML += "최종 arr : " + arr + "<br>";
            // > 원본배열에 영향을 미치는 메소드 



        }
    </script>

    <br>

    <hr>

    <h4>
        8) join(구분자) / toString()
        : 배열에 담긴 값들을 하나의 "문자열" 로 합쳐서
          반환해주는 메소드

    </h4>

    <div id="area9" class="area small"></div>

    <button onclick="toStringJoinTest();">확인하기</button>

    <script>
        function toStringJoinTest(){

            var area9 = document.getElementById("area9");

            // 테스트할 배열 셋팅

            let arr = ["나는", "오늘부터", "공부를", "시작한다!!"];

            area9.innerHTML = "원본 배열 arr :  " + arr/* .toString() */ + "<br>";
            area9.innerHTML += "toString() : " + arr.toString() + "<br>";
            // > 배열명을 html 요소 내에 출력할 경우
            // 내부적으로 .toString() 호출 후 돌아온 결과 출력

            area9.innerHTML += "join : " + arr.join() + "<br>";
            // > join 도 기본적으로 매개변수 제시 안하면
            //   , 로 연이어진 문자열이 나옴


            area9.innerHTML += "구분자 제시한 join : " + arr.join(" ") + "<br>";

            // > 구분자를 매개변수로 제시하면 해당 구분자로 하나의 문자열로 합침
            


        }
    </script>

</body>
</html>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>